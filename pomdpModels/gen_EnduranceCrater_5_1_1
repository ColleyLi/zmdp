#!/usr/bin/perl -w

# generates the EnduranceCrater POMDP

$prob_name = "EnduranceCrater_5_1_1";

$X_SIZE = 5;
$Y_SIZE = $X_SIZE;
@INITIAL_POS = (0,2);
@ROCK_POSITIONS = ([2, 2]
		   );
# position and 'inward direction' (x,y,dx,dy)
@GAPS = ([2, 3,  0, -1],
	 );
@IMPASSABLE_POSITIONS = ([1, 1],
			 [1, 2],
			 [1, 3],
			 [2, 1],
			 [3, 1],
			 [3, 2],
			 [3, 3],
			 );

$TERMINAL_REWARD = 0;
$SAMPLE_GOOD_REWARD = 50;
$SAMPLE_BAD_PENALTY = -50;
$TIME_COST = -1;
$SENSOR_ZERO_DIST_EFF = 0.8;
$SENSOR_HALF_EFF_DISTANCE = 2;

$AS_NUMBERS = 1;

######################################################################
if ($AS_NUMBERS) {
    $prob_file = "$prob_name.pomdp";
} else {
    $prob_file = "${prob_name}_full.pomdp";
}
%DIR_MAP = ('n' => [0,1], 'e' => [1,0], 's' => [0,-1], 'w' => [-1,0]);
$NUM_ROCKS = $#ROCK_POSITIONS+1;
$NUM_GAPS = $#GAPS+1;
$NUM_FEATURES = $NUM_ROCKS + $NUM_GAPS;
@FEATURE_POSITIONS = (@ROCK_POSITIONS, @GAPS);
if ($AS_NUMBERS) {
    $GOOD_OBS = 0;
    $BAD_OBS = 1;
} else {
    $GOOD_OBS = 'ogood';
    $BAD_OBS = 'obad';
}
$DEFAULT_OBSERVATION = [[1,$GOOD_OBS]];

&main();

######################################################################

sub state_to_string {
    my $state = shift;
    # special case for terminal state
    if ($state eq 'st') {
	if ($AS_NUMBERS) {
	    return $X_SIZE * $Y_SIZE * 2**$NUM_FEATURES;
	} else {
	    return 'st';
	}
    }
    my ($x, $y, $r) = @{$state};
    if ($AS_NUMBERS) {
	return $r + 2**$NUM_FEATURES * ($y + $Y_SIZE * $x);
    } else {
	return "s$x$y" . sprintf("%0${NUM_FEATURES}b", $r);
    }
}

sub action_to_string {
    my $action_name = shift;

    if ($AS_NUMBERS) {
	my %direction_map = ("n" => 0,
			     "e" => 1,
			     "s" => 2,
			     "w" => 3);
			  
	my $action_type = substr($action_name,1,1);
	if ($action_type eq 'm') {
	    return $direction_map{substr($action_name,2,1)};
	} elsif ($action_type eq 'c') {
	    return 4 + substr($action_name,2,1);
	} elsif ($action_type eq 's') {
	    return 4 + $NUM_FEATURES;
	}
    } else {
	return $action_name;
    }
}

sub sparse_to_dense {
    my $sparse = shift;
    my $state_list = shift;

    my %smap = ();
    for my $i (0 .. $#{$state_list}) {
	my $s = $state_list->[$i];
        my $ss = &state_to_string($s);
        $smap{$ss} = $i;
	#print STDOUT "$ss => $i\n";
    }
    my @dense = ();
    for (0..$#{$state_list}) { push @dense, 0; }
    for (@{$sparse}) {
	my ($prob, $s) = @{$_};
	my $ss = &state_to_string($s);
	$dense[$smap{$ss}] = $prob;
    }
    return @dense;
}

sub gen_state_list {
    my @state_list = ();
    for my $x (0..($X_SIZE-1)) {
	for my $y (0..($Y_SIZE-1)) {
	    for my $r (0..(2**$NUM_FEATURES-1)) {
		push @state_list, [$x,$y,$r];
	    }
	}
    }
    # add the terminal state
    push @state_list, 'st';

    return @state_list;
}

sub gen_action_list {
    my @action_list = ('amn','ame','ams','amw');
    for my $feature_num (0..($NUM_FEATURES-1)) {
	push @action_list, "ac$feature_num";
    }
    push @action_list, 'as';
    return @action_list;
}

sub gen_observation_list {
    return ($GOOD_OBS,$BAD_OBS);
}

sub gen_start_state {
    # pick an arbitrary initial position
    my $x = $INITIAL_POS[0];
    my $y = $INITIAL_POS[1];

    # uniform probability over all possible feature good/bad values
    my $unif_prob = 1 / (2**$NUM_FEATURES);
    my @sparse = ();
    for my $r (0 .. (2**$NUM_FEATURES-1)) {
	push @sparse, [$unif_prob, [$x,$y,$r]];
    }

    return \@sparse;
}

######################################################################

# each of these functions returns R(s,a), a sparse representation of
# T(s,a,.), and a sparse representation of O(s,a,.)

sub action_result {
    my $s = shift;
    my $a = shift;

    # special case for terminal state
    if ($s eq 'st') {
	return [0, [[1,'st']], $DEFAULT_OBSERVATION];
    }
    
    my $action_type = substr($a,1,1);
    if ($action_type eq 'm') {
	return &move($s,$a);
    } elsif ($action_type eq 'c') {
	return &check($s,$a);
    } elsif ($action_type eq 's') {
	return &sample($s,$a);
    }
}

sub sample {
    my $s = shift;
    my $a = shift;

    my ($x,$y,$r) = @{$s};
    my $rock_num = &which_rock($x,$y);

    # trying to sample when not at a rock has no effect
    if ($rock_num == -1) {
	return [$TIME_COST, [[1,$s]], $DEFAULT_OBSERVATION];
    }

    my $mask = (1 << ($NUM_FEATURES-$rock_num-1));
    my $rock_was_good = ($r & $mask) != 0;
    my $reward = $rock_was_good ? $SAMPLE_GOOD_REWARD : $SAMPLE_BAD_PENALTY;

    # mark the rock sampled as being bad
    my $rp = $r & ~$mask;
    my $sp = [$x,$y,$rp];

    return [$reward, [[1,$sp]], $DEFAULT_OBSERVATION];
}

sub move {
    my $s = shift;
    my $a = shift;

    my ($x,$y,$r) = @{$s};
    my $direction = substr($a,2,1);

    my ($dx, $dy) = @{$DIR_MAP{$direction}};
    my $xp = $x + $dx;
    my $yp = $y + $dy;

    # special case: moving off the right-hand edge puts us in the terminal state
    if ($xp >= $X_SIZE) {
	return [$TERMINAL_REWARD, [[1,'st']], $DEFAULT_OBSERVATION];
    }

    # otherwise, trying to move across a boundary has no effect
    if ($xp >= $X_SIZE or $xp < 0 or $yp >= $Y_SIZE or $yp < 0) {
	return [$TIME_COST, [[1,$s]], $DEFAULT_OBSERVATION];
    }

    # trying to move into an impassable square has no effect
    for my $imp (@IMPASSABLE_POSITIONS) {
	my ($xi,$yi) = @{$imp};
	if ($xp == $xi && $yp == $yi) {
	    return [$TIME_COST, [[1,$s]], $DEFAULT_OBSERVATION];
	}
    }

    # trying to move through a bad gap in the outward direction
    # has no effect and returns the 'bad' observation
    for my $gn (0..$NUM_GAPS-1) {
	my $mask = (1<<($NUM_GAPS-$gn-1));
	my $gap_is_bad = !($r & $mask);
	if ($gap_is_bad) {
	    my ($xg,$yg,$dxg,$dyg) = @{$GAPS[$gn]};
	    if ($xp == $xg && $yp == $yg
		&& (($dx*$dxg + $dy*$dyg) < 0)) {
		return [ $TIME_COST, [[1,$s]], [[1,$BAD_OBS]] ];
	    }
	}
    }

    # and here is the usual case, motion
    my $sp = [$xp,$yp,$r];
    return [$TIME_COST, [[1,$sp]], $DEFAULT_OBSERVATION];
}

sub check {
    my $s = shift;
    my $a = shift;

    my ($x,$y,$r) = @{$s};
    my $feature_num = substr($a,2,1);

    # sensor efficiency depends on distance from the feature
    my ($rx,$ry) = @{$FEATURE_POSITIONS[$feature_num]};
    my $d = sqrt(($x - $rx)**2 + ($y - $ry)**2);
    my $eff = $SENSOR_ZERO_DIST_EFF * exp(-$d*log(2)/$SENSOR_HALF_EFF_DISTANCE);
    
    # at efficiency 1, the sensor always tells you the right answer;
    # at efficiency 0, it tells you 50/50.  in between, a linear combination.
    my $feature_is_good = ($r & (1 << ($NUM_FEATURES-$feature_num-1))) != 0;
    my $chance_positive = $eff * $feature_is_good + (1 - $eff) * 0.5;
    my $chance_negative = 1 - $chance_positive;

    return [$TIME_COST,
	    [[1,$s]],
	    [[$chance_positive,$GOOD_OBS],[$chance_negative,$BAD_OBS]]];
}

######################################################################

sub which_rock {
    my $x = shift;
    my $y = shift;

    for $i (0 .. $#ROCK_POSITIONS) {
	my ($xp,$yp) = @{$ROCK_POSITIONS[$i]};
	if ($xp == $x and $yp == $y) {
	    return $i;
	}
    }
    return -1;
}

######################################################################

sub main {
    open(OUT, ">$prob_file") or die "couldn't open $prob_file for writing: $!\n";
    select OUT;
    
    print << "EOF"; #####################################################
# state naming convention: s <x> <y> <rock_0> .. <rock_{n_r-1}> <gap_0> .. <gap_{n_g-1}>
# action naming convention:
#   amn, ame, ams, amw: move in the cardinal directions
#   ac0, ac1 .. ac{n_r+n_g-1}: do the "check" action on the indicated rock or gap
#   as: sample the rock in the robot's square
# observation naming convention:
#   ogood, obad: the check sensor is indicating a "good" or "bad" reading
#                for the rock or gap.  actions other than check always return ogood.
EOF
######################################################################
    print "# initial position is: ($INITIAL_POS[0], $INITIAL_POS[1])\n";

    print "# rock positions are: ";
    for (@ROCK_POSITIONS) {
	print "($_->[0],$_->[1]) ";
    }
    print "\n";
    print "# gaps are [pos and inward direction (x,y,dx,dy)]:\n";
    for (@GAPS) {
	print "#   ($_->[0],$_->[1],$_->[2],$_->[3])\n";
    }
    print "\n";

    print "discount: 0.99\n";
    print "values: reward\n";
    
    # print list of actions
    my @action_list = &gen_action_list();
    if ($AS_NUMBERS) {
	print "actions: ", (4 + $NUM_FEATURES + 1), "\n";
    } else {
	print "actions: ", join(" ", map { &action_to_string($_); } @action_list), "\n";
    }

    # print list of observations
    my @observation_list = &gen_observation_list();
    if ($AS_NUMBERS) {
	print "observations: 2\n";
    } else {
	print "observations: ", join(" ", @observation_list), "\n\n";
    }

    # print list of states
    my @state_list = &gen_state_list();
    if ($AS_NUMBERS) {
	print "states: ", ($X_SIZE * $Y_SIZE * 2**$NUM_FEATURES + 1), "\n\n";
    } else {
	print "states: ", join(" ", map { &state_to_string($_); } @state_list), "\n\n";
    }

    my @start_state = &sparse_to_dense(&gen_start_state(), \@state_list);
    print "start: ", join(" ", @start_state), "\n\n";

    # i don't think these are necessary; they may slow down the reading process
    #   considerably
    #print "R: * : * : * : * 0.0\n";
    #print "T: * : * : * 0.0\n";
    #print "O: * : * : * 0.0\n";

    print "E: ", &state_to_string("st"), "\n";
    print "\n";

    for my $s (@state_list) {
	my $ss = &state_to_string($s);
	for my $a (@action_list) {
	    my $as = &action_to_string($a);
	    my ($R,$T,$O) = @{&action_result($s,$a)};
	    printf("R: %-3s : %-10s : * : * %f\n",
		   $as, $ss, $R);
	    for (@{$T}) {
		my ($prob, $sp) = @{$_};
		printf("T: %-3s : %-10s : %-10s %f\n",
		       $as, $ss, &state_to_string($sp), $prob);
	    }
	    for (@{$O}) {
		my ($prob, $o) = @{$_};
		printf("O: %-3s : %-10s : %-10s %f\n",
		       $as, $ss, $o, $prob);
	    }
	    print "\n";
	}
    }
    
    close(OUT);
}

