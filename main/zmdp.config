# $Revision: 1.8 $  $Author: trey $  $Date: 2006-10-20 20:00:16 $

# searchStrategy: Specifies search strategy.  Valid choices are
# 'frtdp', 'hsvi', 'rtdp', 'lrtdp', 'hdp', and 'script'.  ('script'
# reads a fixed sequence of states to back up from input files;
# see the 'backupScriptInputDir' parameter below.)
searchStrategy frtdp

# modelType: Specifies the type of planning model.  Valid choices are
# '-', 'racetrack', and 'pomdp'.  '-' tells ZMDP to infer the model type
# from its filename extension. 'racetrack' means the model is from the
# racetrack MDP benchmark domain.  'pomdp' means the model is in Tony
# Cassandra's POMDP file format.
modelType -

# valueFunctionRepresentation: Specifies how to represent the value
# function.  Valid choices are '-', 'point', and 'convex'.  '-' tells
# ZMDP to use the default representation for the given model type
# ('point' for MDP problems and 'convex' for POMDP problems).  Note:
# 'convex' only makes sense for POMDPs.
valueFunctionRepresentation -

# policyOutputFile: Specifies where to write the output policy.  ZMDP
# outputs the current policy at the following times: (1) at each
# evaluation epoch [when using zmdpBenchmark], and (2) whenever the run
# terminates for any reason (target regret bound reached, timeout, or
# ctrl-C user interrupt).  Note that policies can currently only be
# output if modelType = pomdp and valueFunctionRepresentation = convex.
# '-' tells ZMDP to write the policy to 'out.policy' if the zmdpSolve
# front-end is used and disable policy output otherwise.  'none' tells
# ZMDP to disable policy output.
policyOutputFile -

# useFastPomdpParser: Specify 0 or 1.  If value is 0, Tony Cassandra's
# canonical parser is used to parse POMDPs.  If value is 1, ZMDP's
# built-in POMDP parser is used.  ZMDP's parser is much faster for large
# problems but does not support all the constructs in Cassandra's POMDP
# specification language (for instance, states must be identified
# numerically rather than with string identifiers).  Most POMDPs in
# Cassandra's POMDP repository are not compatible with the fast parser
# as-is, but could be translated to the language subset it understands.
# See the RockSample problems for a compatible example.
useFastPomdpParser 0

# terminateRegretBound: If set to a positive value, the solution
# algorithm will terminate when the regret of the current policy with
# respect to the optimal policy is bounded to the specified value.
terminateRegretBound 1e-3

# terminateWallclockSeconds: If set to a positive value, the solution
# algorithm will terminate after running for the specified amount of
# wallclock time.  The termination check excludes time spent outside the
# solution algorithm, e.g. reading model files and evaluating policies
# for benchmark purposes.  Also note that the termination check is only
# performed at the end of trials, so the reported final wallclock time
# will usually exceed the specified termination condition.
terminateWallclockSeconds -1

# terminateNumBackups (integer): If set to a positive value, terminate
# after the specified number of backups have been performed by the
# heuristic search algorithm.  Note that the termination check is only
# performed at the end of trials, so the reported final number of backups
# will usually exceed the specified termination condition.
terminateNumBackups -1

# maxHorizon (integer): If set to a positive value, informs ZMDP that
# the system is guaranteed to enter a zero-reward absorbing state after
# at most the specified number of time steps.  This hint is used to
# calculate tighter initial bounds (currently only used for POMDP
# problems).  Note: If the problem is an undiscounted POMDP, you must
# specify a maxHorizon value.
maxHorizon -1

# useWeakUpperBoundHeuristic: Specify 0 or 1.  If 1, avoid spending time
# generating a good upper bound heuristic.  This only applies to some
# problems and interpretation depends on the problem; e.g., sets h_U = 0
# for racetrack.
useWeakUpperBoundHeuristic 0

# maintainLowerBound: Specify '-', 0, or 1.  If 1, maintain a lower
# bound on the optimal value function during search.  If '-', maintain
# the lower bound only if it is required for the given search algorithm
# (it is required for 'frtdp' and 'hsvi').
maintainLowerBound -

# maintainUpperBound: Specify 0 or 1.  If 1, maintain an upper bound
# on the optimal value function during search.  All the search strategies
# except 'script' require maintainUpperBound=1.
maintainUpperBound 1

# runTimeActionSelection: Specify '-', 'upper', or 'lower'.  Run-time
# (i.e., evaluation epoch time) action selection uses one-step lookahead
# with either the upper or lower bound based on what you specify.  '-'
# tells ZMDP to use the lower bound if it is available and fall back to
# the upper bound otherwise.
runTimeActionSelection -

# evaluationTrialsPerEpoch: Specifies the number of simulation trials to
# run at each policy evaluation epoch.  The reported policy quality for
# the epoch is the mean reward achieved over the set of trials.
# [does not apply to zmdpSolve]
evaluationTrialsPerEpoch 100

# evaluationMaxStepsPerTrial: If set to a positive value, specifies the
# maximum number of time steps to run each simulation trial when
# evaluating policy quality.  Note that ZMDP will automatically terminate
# a trial if the system enters a zero-reward absorbing state, so if
# your model guarantees this will happen in finite time you may find you
# don't need to set this parameter.
# [does not apply to zmdpSolve]
evaluationMaxStepsPerTrial 251

# evaluationFirstEpochWallclockSeconds: Specifies the amount of
# wallclock time to run the solution algorithm for before the first
# policy evaluation epoch.  Note: because the benchmark driver can only
# run evaluation epochs when the solution algorithm yields control, the
# actual epoch timing is not guaranteed to match what you specify.  The
# timing guarantees are that (1) the evaluation epoch will start *after*
# the time you specify, and (2) the actual elapsed wallclock time will
# be accurately logged in the benchmark output used for plotting.
# [does not apply to zmdpEvaluate or zmdpSolve]
evaluationFirstEpochWallclockSeconds 1.0

# evaluationEpochsPerMagnitude: Evaluation epoch timing is spaced
# logarithmically according to elapsed wallclock time.  This parameter
# specifies the number of epochs per order of magnitude in a log plot.
# For instance, if 3 is specified, there will be three epochs between 10
# and 100 seconds elapsed, three between 100 and 1000 seconds elapsed,
# etc.
# [does not apply to zmdpEvaluate or zmdpSolve]
evaluationEpochsPerMagnitude 10

# evaluationOutputFile: Specifies where to write results from policy
# evaluation.  The resulting file has one line per epoch.
# [does not apply to zmdpEvaluate or zmdpSolve]
evaluationOutputFile inc.plot

# boundsOutputFile: Specifies where to write data on bounds at the
# initial state. The resulting file has one line per top-level
# trial of the search algorithm.
# [does not apply to zmdpEvaluate or zmdpSolve]
boundsOutputFile bounds.plot

# simulationTraceOutputFile: Specifies where to write logs of simulator
# state/belief, actions selected, etc. during policy evaluation.  The
# resulting file has two lines per time step of simulation.
# [does not apply to zmdpSolve]
simulationTraceOutputFile sim.plot

# simulationTracesToLogPerEpoch (integer): If set to a non-negative
# value, specifies the number of simulation traces to log at each
# evaluation epoch.  If set to a negative value, all traces are logged
# (note: this can lead to very large log files!).
# [does not apply to zmdpSolve]
simulationTracesToLogPerEpoch 1

# useTimeWithoutHeuristic: Specify 0 or 1.  If 1, the wallclock times
# reported in zmdpBenchmark performance logs will *not* include the time
# taken to generate initial bounds.  Instead, they will only include
# time spent in heuristic search trials.  This option allows you to
# eliminate one confounding factor in the timing when comparing
# different algorithms with the same initialization procedure.  Of
# course, you should not turn it on when comparing algorithms that use
# different initialization procedures.
useTimeWithoutHeuristic 1

# useConvexSupportList: Specify 0 or 1.  If 1 (and using 'convex' value
# functions), use support lists to restrict value function queries.
# Support lists leverage sparsity and tend to provide much faster
# queries at the cost of less value function generalization (because
# each update only applies to a portion of the belief simplex).  Sorry,
# there is no detailed documentation on this feature yet.
useConvexSupportList 1

# useLogBackups: Specify 0 or 1.  If 1, generate the logs specified
# by the stateIndexOutputFile and backupsOutputFile parameters.
# [does not apply to zmdpSolve or zmdpEvaluate]
useLogBackups 0

# stateIndexOutputFile: Specifies where to write an index of states (or
# POMDP beliefs) that are referenced in other log files.  The index
# file provides a unique numeric identifier for every state of interest.
# [does not apply to zmdpSolve or zmdpEvaluate]
stateIndexOutputFile stateIndex.log

# backupsOutputFile: Specifies where to write a log of state (or POMDP
# belief) backups.  The log is in chronological order and contains one
# line per backup made.  The line lists the index number (from the
# stateIndexOutputFile) for the backed up state.
# [does not apply to zmdpSolve or zmdpEvaluate]
backupsOutputFile backups.log

# backupScriptInputDir: If searchStrategy='script', ZMDP will read a
# sequence of states to back up from the given directory.  Specifically,
# ZMDP tries to read the sequence from files in the directory with the
# names given in the 'stateIndexOutputFile' and 'backupsOutputFile'
# parameters.  This allows you to repeat the exact sequence of updates
# from an earlier run, even if you are using different parameters that
# would normally affect which states are updated (e.g. a different value
# function representation).
# [does not apply to zmdpSolve or zmdpEvaluate]
backupScriptInputDir none

# boundValuesOutputFile: Specifies where to write a list of state
# (or POMDP belief) bound values.  The list is written if either
# searchStrategy='script' or useLogBackups=1.  It includes lower and
# upper bound values for the states in the index file.
boundValuesOutputFile boundValues.log
