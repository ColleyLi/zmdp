README for zmdp

This C++ source code implements several approximate value iterations for
MDPs and POMDPs, including HSVI2 [6], RTDP [1], LRTDP [3], HDP [2],
and FRTDP [not yet published].  The software takes a problem specification
as input.  Currently supported specification formats are Tony Cassandra's
POMDP file format [4] and a new format for describing problems in the
racetrack domain from [1].

Special note: my implementations of some of these algorithms are based
on publications that necessarily left out a lot of detail.  It's quite
possible that my implementation differs from the original in important
ways.  The original authors have not signed off on my implementations:
use at your own risk.  (And please inform me if you find any errors.)

More information can be found at http://www.cs.cmu.edu/~trey/zmdp

Please let me know if you have any comments!

Trey Smith <trey@ri.cmu.edu>

Copyright (c) 2005-2006, Trey Smith.  All rights reserved.
More information is in the file named COPYING.

Table of contents of this README
* release notes
* package contents
* usage instructions
* example sessions
* plotting results
* acknowledgments
* references

========================================================================
RELEASE NOTES

Changes from zpomdp 0.1 to zmdp 0.2

* zmdp now includes MDP solving as well as POMDP solving
  capabilities (hence the name change).

* Created uniform MDP/POMDP API so that POMDPs formulated as
  belief-space MDPs can be passed to MDP heuristic search algorithms.

* Some code has been refactored to reduce code duplication and
  provide cleaner interfaces.  This involved shuffling directories.

* Implemented racetrack domain and some sample problems from the
  literature.

* Implemented RTDP, LRTDP, HDP, HDP+L, and FRTDP.

* Separate binaries are now produced for each (problem type, algorithm)
  pair rather than a single unified binary.

zpomdp 0.1

* Initial release.

========================================================================
PACKAGE CONTENTS

src/build        Makefile system
src/common       Utility code, including a sparse linear algebra library
src/pomdpParser  POMDP problem parsing code (thanks to Tony Cassandra!)
src/pomdpCore    Basic POMDP operations and value function heuristics
src/mdps         Racetrack domain and some example problems
src/hsvi2        HSVI2 algorithm
src/rtdp         RTDP, LRTDP, HDP, and FRTDP algorithms
src/main         Binaries for invoking algorithms from the shell
src/problems     Problems from [5] and a trivial example.
src/tools        Tools for scripting multiple runs and plotting results.

========================================================================
USAGE INSTRUCTIONS

To get started please first follow the instructions in INSTALL.

There are several binaries produced by the installation process, found
in the bin/linux2 directory.  They are named as
solve<problemType><algorithm>, for example: solvePomdpHsvi or
solveRaceTrackRtdp.  (Usage instructions for solvePomdpHsvi copied
here.)

usage: solvePomdpHsvi OPTIONS <problem.pomdp> [minOrder maxOrder]
  -h or --help           Print this help
  --version              Print version information (CFLAGS used at compilation)
  -f or --fast           Use fast (but very picky) alternate problem parser
  -i or --iterations     Set number of simulation iterations (default: 1000)
  -p or --precision      Set target precision
  --heuristic            Use a non-trivial upper bound heuristic (interpretation
                           depends on the problem)

========================================================================
EXAMPLE SESSIONS

(Examples assume the solvePomdpHsvi binary is in your path.)

COMMAND:

  solvePomdpHsvi -i 100 problems/three_state.pomdp -- -1 1

EXPLANATION:

  The '-i 100' flag sets the number of iterations that should be used
  when evaluating solution quality at each simulation epoch.  Reducing
  the number of iterations decreases the total testing time but provides
  less precision in the solution quality measurement (reflected in wider
  error bars for plots).

  'problems/three_state.pomdp' indicates what problem to solve.

  '--' is a special marker to prevent later arguments that begin
  with '-' from being interpreted as flags.  If this is not used
  the '-1' argument later will cause an error.

  '-1 1' are the minOrder and maxOrder, specifying when to insert
  simulation epochs for testing solution quality.  The first epoch comes
  after the solution algorithm has run for 10^minOrder seconds.
  Subsequent epochs are spaced logarithmically with three epochs per
  order of magnitude of running time.  This is nice for semi-log plots.
  After 10^maxOrder seconds the test run ends.  NOTE: to be more
  accurate, testing epochs can only be inserted when the solution
  algorithm yields control to the testing harness, so the logarithmic
  spacing rule is only approximate.

COMMAND:

  solvePomdpHsvi -f problems/RockSample_5_7.pomdp 0 3

EXPLANATION:

  Mostly the same as the previous explanation.  Note maxOrder=3 for a
  longer run.  The '-f' flag tells testPomdp to use a faster problem
  parser that is also very picky.  The fast parser will probably only
  accept RockSample problems, but you will really want to use it on
  large problem instances!

========================================================================
PLOTTING RESULTS

Two of the plotting scripts in the src/tools directory are worth
mentioning.

=== MAKEPLOT

usage: makeplot OPTIONS <results_directory>
   -h    Print this help
   -i    Plot bounds vs. number of top-level iterations
   -p    Generate postscript output

makeplot plots the HSVI2 upper bound, lower bound, and measured solution
quality at testing epochs in a single graph with a logarithmic x axis.
It looks in <results_directory> for the files bounds.plot and inc.plot,
output by testPomdp.  By default the plot is displayed in an X window.
Using the -p option drops it into a PostScript file instead, e.g. for
inclusion in a paper.

=== COMPAREPLOTS

usage: compareplots OPTIONS <dir1> <dir2>
   -h    Print this help
   -t    Plot bounds vs. time
   -i    Plot bounds vs. number of top-level iterations
   -s    Plot speed (iterations v. time)
   -p    Generate postscript output
  
compareplots is similar to makeplot but pulls in results from two
directories.  The plot that comes out is very busy, but still useful
to look at performance differences between algorithm variants.

========================================================================
ACKNOWLEDGMENTS

Thanks to Geoff Gordon for helpful discussions.  Thanks to Tony
Cassandra for developing the POMDP problem format and distributing his
problem reading and solution code.  Thanks to Matthijs Spaan for
distributing his PERSEUS POMDP-solving code, which provided a template
for my release of zmdp.

========================================================================
REFERENCES

[1] Learning to Act Using Real-Time Dynamic Programming.
    A. Barto, S. Bradke, and S. Singh.
    Artificial Intelligence 72(1-2): 81-138. 1995.

[2] Faster heuristic Search Algorithms for Planning with
     Uncertainty and Full Feedback.
    B. Bonet and H. Geffner. In Proc. of IJCAI, 2003.

[3] Labeled RTDP: Improving the Convergence of Real Time Dynamic Programming.
    B. Bonet and H. Geffner. In Proc. of ICAPS, 2003.

[4] Tony's POMDP Page. Tony Cassandra.
    http://www.cs.brown.edu/research/ai/pomdp/

[5] Heuristic Search Value Iteration for POMDPs.
    T. Smith and R. Simmons. In  Proc. of UAI, 2004.
    http://www.cs.cmu.edu/~trey/papers/smith04_hsvi.pdf

[6] Point-based POMDP Algorithms: Improved Analysis and Implementation.
    T. Smith and R. Simmons. In Proc. of UAI, 2005.
    http://www.cs.cmu.edu/~trey/papers/smith05_point_based_pomdp.pdf

==========================================================
$Id: README,v 1.2 2006-02-27 20:14:03 trey Exp $
